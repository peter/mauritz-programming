<html>
  <head>
    <meta charset="utf-8" />
    <title>Matteutmaning - Tabell med Bokstäver</title>
  </head>
  <body>
    <script>
      function invertObject(obj) {
        return Object.entries(obj).reduce((acc, [key, value]) => {
          acc[value] = key;
          return acc;
        }, {});
      }

      function max(list) {
        return list.reduce((acc, value) => (acc > value ? acc : value));
      }

      function swapItems(list, index1, index2) {
        const result = [];
        for (const [index, item] of list.entries()) {
          if (index === index1) {
            result.push(list[index2]);
          } else if (index === index2) {
            result.push(list[index1]);
          } else {
            result.push(item);
          }
        }
        return result;
      }

      function uniq(array) {
        const seen = {};
        const result = [];
        for (const item of array) {
          if (!seen[item]) result.push(item);
          seen[item] = true;
        }
        return result;
      }

      function randomIndex(list) {
        return Math.round(Math.random() * (list.length - 1));
      }

      function randomList(list) {
        return list.map(v => list[randomIndex(list)]);
      }

      function shuffle(list) {
        const remaining = [...list];
        const result = [];
        while (remaining.length > 0) {
          const index = randomIndex(remaining);
          result.push(remaining[index]);
          remaining.splice(index, 1);
        }
        return result;
      }

      function sum(list) {
        return list.reduce((acc, value) => acc + value, 0);
      }

      function range(length) {
        const result = [];
        for (let i = 0; i < length; ++i) {
          result.push(i);
        }
        return result;
      }

      function variableValue(variables, variable) {
        return variables.findIndex(v => v === variable) + 1;
      }

      function orderedVariables(length) {
        return range(length).map(index => String.fromCharCode(65 + index));
      }

      function isCorrectSolution(variables, table) {
        const value = v => variableValue(variables, v);
        for (let rowIndex = 0; rowIndex < table.rows.length; ++rowIndex) {
          if (table.rowSums[rowIndex] !== sum(table.rows[rowIndex].map(value)))
            return false;
        }
        for (
          let columnIndex = 0;
          columnIndex < table.rows.length;
          ++columnIndex
        ) {
          if (
            table.columnSums[columnIndex] !==
            sum(table.rows.map(row => value(row[columnIndex])))
          )
            return false;
        }
        return true;
      }

      function getSolutionStatuses(state) {
        const value = v => state.solution[v] || 0;
        const table = state.table;
        const getStatus = (correctSum, solutionSum, nMissing) => {
          if (Object.keys(state.solution).length === 0) return undefined;
          if (nMissing > 0) {
            if (
              solutionSum > correctSum ||
              correctSum - solutionSum < nMissing
            ) {
              return "incorrect";
            } else {
              return "potential";
            }
          } else {
            return solutionSum === correctSum ? "correct" : "incorrect";
          }
        };
        const rowStatuses = {};
        for (let rowIndex = 0; rowIndex < table.rows.length; ++rowIndex) {
          const values = table.rows[rowIndex].map(value);
          const nMissing = values.filter(v => v === 0).length;
          rowStatuses[rowIndex] = getStatus(
            table.rowSums[rowIndex],
            sum(values),
            nMissing
          );
        }

        const columnStatuses = {};
        for (
          let columnIndex = 0;
          columnIndex < table.rows.length;
          ++columnIndex
        ) {
          const values = table.rows.map(row => value(row[columnIndex]));
          const nMissing = values.filter(v => v === 0).length;
          columnStatuses[columnIndex] = getStatus(
            table.columnSums[columnIndex],
            sum(values),
            nMissing
          );
        }

        return { rowStatuses, columnStatuses };
      }

      function getSolutionStatusColor(status) {
        return {
          potential: "yellow",
          correct: "green",
          incorrect: "red"
        }[status];
      }

      function element(name, attributes = {}) {
        const el = document.createElement(name);
        for (const [key, value] of Object.entries(attributes)) {
          el.setAttribute(key, value);
        }
        return el;
      }

      function getTable(variables) {
        const value = v => variableValue(variables, v);
        let rows = variables.map(() => randomList(variables));
        const rowSums = rows.map(row => sum(row.map(value)));
        const columnSums = variables.map((_, columnIndex) =>
          sum(rows.map(row => value(row[columnIndex])))
        );
        return { rows, rowSums, columnSums };
      }

      function getMatrix(table) {
        const variables = orderedVariables(parseInt(table.rows.length));
        const rows = [];
        const values = [];
        const getMatrixRow = letters => {
          return variables.map(
            letter => letters.filter(l => l == letter).length
          );
        };
        rows.push(getMatrixRow(variables));
        values.push(sum(variables.map(v => variableValue(variables, v))));
        for (const [index, row] of table.rows.entries()) {
          rows.push(getMatrixRow(row));
          values.push(table.rowSums[index]);
        }
        for (const [index, sum] of table.columnSums.entries()) {
          const column = table.rows.map(row => row[index]);
          rows.push(getMatrixRow(column));
          values.push(sum);
        }
        return {
          description: "Matrix before gaussian elimination",
          rows,
          values
        };
      }

      function gaussEliminate(matrix) {
        let result = matrix;
        let results = [result];
        const nColumns = result.rows[0].length;
        for (let rowIndex = 0; rowIndex < nColumns; ++rowIndex) {
          // Get maxRowIndex of column rowIndex
          const column = result.rows.slice(rowIndex).map(r => r[rowIndex]);
          const columnMax = max(column.map(Math.abs));
          const maxColumnIndex = column.findIndex(
            v => Math.abs(v) === columnMax
          );
          const maxRowIndex = maxColumnIndex + rowIndex;
          // Swap maxRowIndex with rowIndex row if maxRowIndex !== rowIndex
          if (maxColumnIndex > -1 && maxRowIndex !== rowIndex) {
            result = {
              ...result,
              description: `Swap row ${maxRowIndex} with row ${rowIndex} to get maximum pivot ${columnMax} for row ${rowIndex}`,
              rows: swapItems(result.rows, rowIndex, maxRowIndex),
              values: swapItems(result.values, rowIndex, maxRowIndex)
            };
            results.push(result);
          }
        }
        for (let rowIndex = 0; rowIndex < nColumns; ++rowIndex) {
          // Multiply rowIndex with 1/rowIndex,rowIndex to achieve diagonal of 1:s
          const pivot = result.rows[rowIndex][rowIndex];
          if (pivot === 0) continue;
          if (pivot !== 1) {
            const pivotRow = result.rows[rowIndex].map(v => v / pivot);
            result = {
              ...result,
              description: `Multiply row ${rowIndex} with ${1 /
                pivot} to get a pivot value of 1`,
              rows: result.rows.map((r, i) => (i === rowIndex ? pivotRow : r)),
              values: result.values.map((v, i) =>
                i === rowIndex ? v / pivot : v
              )
            };
            results.push(result);
          }
          // Create zeros under the pivot
          for (
            let pivotIndex = rowIndex + 1;
            pivotIndex < nColumns;
            ++pivotIndex
          ) {
            const underPivotValue = result.rows[pivotIndex][rowIndex];
            if (underPivotValue !== 0) {
              const underPivotRow = result.rows[pivotIndex].map(
                (v, i) => v - underPivotValue * result.rows[rowIndex][i]
              );
              result = {
                ...result,
                description: `Subtract row ${pivotIndex} with ${underPivotValue} times row ${rowIndex} to create a zero under the pivot at row ${pivotIndex}`,
                rows: result.rows.map((r, i) =>
                  i === pivotIndex ? underPivotRow : r
                ),
                values: result.values.map((v, i) =>
                  i === pivotIndex ? v / underPivotValue : v
                )
              };
              results.push(result);
            }
          }
        }
        // Back substitution to create zeros above the pivots (diagonal) and yield the final result (if possible)
        for (let rowIndex = nColumns - 1; rowIndex > 0; --rowIndex) {
          for (let pivotIndex = rowIndex - 1; pivotIndex >= 0; --pivotIndex) {
            const overPivotValue = result.rows[pivotIndex][rowIndex];
            if (overPivotValue !== 0) {
              const overPivotRow = result.rows[pivotIndex].map((v, i) =>
                i === rowIndex ? 0 : v
              );
              result = {
                ...result,
                description: `Substitute value from row ${rowIndex} into row ${pivotIndex} to yield a zero above pivot (i.e. in cell ${pivotIndex}, ${rowIndex})`,
                rows: result.rows.map((r, i) =>
                  i === pivotIndex ? overPivotRow : r
                ),
                values: result.values.map((v, i) =>
                  i === pivotIndex
                    ? v - overPivotValue * result.values[rowIndex]
                    : v
                )
              };
              results.push(result);
            }
          }
        }
        return results;
      }

      function getSolutionVariables(solution) {
        const solutionByValue = invertObject(solution);
        return Object.keys(solutionByValue)
          .map(v => parseInt(v))
          .sort()
          .map(v => solutionByValue[v]);
      }

      function initState(nVariables) {
        const variables = shuffle(orderedVariables(parseInt(nVariables)));
        const table = getTable(variables);
        STATE = {
          nVariables,
          variables,
          solution: {},
          table,
          matrix: getMatrix(table)
        };
      }

      function renderParameters(state, config) {
        const contents = document.getElementById("contents");
        const parameters = element("div", {
          id: "parameters",
          style: "margin-bottom: 10px"
        });
        const select = element("select");
        const updateNVariables = () => {
          initState(parseInt(select.value));
          render();
        };
        for (const value of config.nVariables.range) {
          const option = element("option");
          option.value = value;
          option.text = value;
          if (value === state.nVariables)
            option.setAttribute("selected", "selected");
          select.appendChild(option);
        }
        select.addEventListener("change", () => updateNVariables());
        parameters.appendChild(select);
        return parameters;
      }

      function renderTable(state, config) {
        const table = element("table", {
          id: "table",
          border: "1",
          cellspacing: "10",
          cellpadding: "10"
        });
        const { rowStatuses, columnStatuses } = getSolutionStatuses(state);
        const renderCell = (label, status = null) => {
          const style =
            status && `background-color: ${getSolutionStatusColor(status)}`;
          const td = element("td", { style });
          td.innerHTML = label;
          return td;
        };
        const renderRow = (rowLabels, statuses = {}) => {
          const tr = element("tr");
          for (const [index, label] of rowLabels.entries()) {
            const td = renderCell(label, statuses[index]);
            tr.appendChild(td);
          }
          table.appendChild(tr);
          return tr;
        };
        for (const [index, row] of state.table.rows.entries()) {
          const tr = renderRow(row);
          const td = renderCell(state.table.rowSums[index], rowStatuses[index]);
          tr.appendChild(td);
        }
        renderRow(state.table.columnSums, columnStatuses);
        return table;
      }

      function isValidSolution(state) {
        const numbersValid = Object.values(state.solution).every(value => {
          const intValue = parseInt(value);
          return (
            !isNaN(intValue) && intValue >= 1 && intValue <= state.nVariables
          );
        });
        const numbersUnique =
          Object.values(state.solution).length ===
          uniq(Object.values(state.solution)).length;
        return numbersValid && numbersUnique;
      }

      function updateSolution(state, letter, value) {
        if (value === "") {
          delete state.solution[letter];
        } else if (!isNaN(parseInt(value))) {
          state.solution[letter] = parseInt(value);
        }
        const isComplete =
          Object.keys(state.solution).length === state.nVariables;
        if (isComplete && isValidSolution(state)) {
          const variables = getSolutionVariables(state.solution);
          if (isCorrectSolution(variables, state.table)) {
            // alert("Rätt lösning!!");
          }
        }
        render();
      }

      function solutionRenderColor(state) {
        const getStatus = () => {
          const isEmpty = Object.keys(state.solution).length === 0;
          const isComplete =
            Object.keys(state.solution).length === state.nVariables;
          const isValid = isValidSolution(state);
          if (isEmpty) return "empty";
          if (!isComplete && isValid) return "potential";
          return isValid ? "correct" : "incorrect";
        };
        return getSolutionStatusColor(getStatus());
      }

      function renderSolution(state, config) {
        const bgColor = solutionRenderColor(state);
        const solution = element("div", {
          style: `margin-top: 10px;`
        });
        const letters = orderedVariables(state.nVariables);
        for (const [index, letter] of letters.entries()) {
          const div = element("div", {
            style: `display: inline; margin-right: 10px;  background-color: ${bgColor}`
          });
          const id = `letter-${index}`;
          const label = element("label", { for: id });
          label.innerHTML = `${letter}=`;
          div.appendChild(label);
          const input = element("input", { id, size: "2" });
          if (state.solution[letter]) input.value = state.solution[letter];
          input.addEventListener("input", () =>
            updateSolution(state, letters[index], input.value)
          );
          div.appendChild(input);
          solution.appendChild(div);
        }
        return solution;
      }

      function renderMatrix(matrix, previousMatrix = null) {
        const table = element("table", {
          id: "matrix",
          border: "1",
          cellspacing: "10",
          cellpadding: "10",
          style: "margin-top: 20px",
          width: `${matrix.rows[0].length * 100}px`
        });
        const renderCell = (label, changed) => {
          const attributes = changed
            ? { style: "background-color: lightgray" }
            : {};
          const td = element("td", attributes);
          td.innerHTML = label;
          return td;
        };
        const renderRow = (rowLabels, previousLabels) => {
          const tr = element("tr");
          for (const [index, label] of rowLabels.entries()) {
            const changed = previousLabels && label !== previousLabels[index];
            const td = renderCell(label, changed);
            tr.appendChild(td);
          }
          table.appendChild(tr);
          return tr;
        };
        if (matrix.description) {
          const tr = element("tr");
          const td = element("td", { colspan: matrix.rows[0].length });
          td.innerHTML = matrix.description;
          tr.appendChild(td);
          table.appendChild(tr);
        }
        for (const [index, row] of matrix.rows.entries()) {
          const previousRow = previousMatrix && previousMatrix.rows[index];
          const tr = renderRow(row, previousRow);
          const changed =
            previousMatrix &&
            matrix.values[index] !== previousMatrix.values[index];
          const td = renderCell(matrix.values[index], changed);
          tr.appendChild(td);
        }
        return table;
      }

      function renderContents(state, config) {
        const contents = document.getElementById("contents");
        contents.innerHTML = "";
        contents.appendChild(renderParameters(state, config));
        contents.appendChild(renderTable(state, config));
        contents.appendChild(renderSolution(state, config));
        const matrixResults = gaussEliminate(state.matrix);
        for (const [index, result] of matrixResults.entries()) {
          contents.appendChild(renderMatrix(result, matrixResults[index - 1]));
        }
      }

      const CONFIG = {
        nVariables: {
          default: 4,
          range: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
        }
      };
      let STATE = {};

      function render() {
        renderContents(STATE, CONFIG);
      }

      window.addEventListener("load", () => {
        initState(CONFIG.nVariables.default);
        render();
      });
    </script>

    <h1>Matteutmaning - Tabell med Bokstäver</h1>
    <div id="contents"></div>
    <div id="debug"></div>
  </body>
</html>
